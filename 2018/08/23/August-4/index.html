<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="be a bird, feather matters"><title>LeetCode note Aug-4 | Drew's Tahiti</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeetCode note Aug-4</h1><a id="logo" href="/.">Drew's Tahiti</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Ãœber</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeetCode note Aug-4</h1><div class="post-meta">Aug 23, 2018<span> | </span><span class="category"><a href="/categories/Algorithm/">Algorithm</a></span></div><div class="post-content"><h3 id="297-H-Serialize-and-Deserialize-Binary-Tree"><a href="#297-H-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. [H]Serialize and Deserialize Binary Tree"></a>297. [H]Serialize and Deserialize Binary Tree</h3><ol>
<li><p>we could use BFS to serialize and deserialize the binary tree. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode currNode = queue.poll();</span><br><span class="line">            sb.append(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">if</span> (currNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(currNode.left);</span><br><span class="line">                sb.append(currNode.left.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">if</span> (currNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(currNode.right);</span><br><span class="line">                sb.append(currNode.right.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] dataArray = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (dataArray.length == <span class="number">1</span> &amp;&amp; dataArray[<span class="number">0</span>] == <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(dataArray[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; dataArray.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">            TreeNode currRoot = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"null"</span>.equals(dataArray[index])) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = Integer.valueOf(dataArray[index]);</span><br><span class="line">                TreeNode left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                currRoot.left = left;</span><br><span class="line">                queue.offer(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index+<span class="number">1</span> &lt; dataArray.length &amp;&amp; !<span class="string">"null"</span>.equals(dataArray[index+<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = Integer.valueOf(dataArray[index+<span class="number">1</span>]);</span><br><span class="line">                TreeNode right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                currRoot.right = right;</span><br><span class="line">                queue.offer(right);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dfs pre-order tree traversal</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traceTree(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceTree</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        sb.append(<span class="string">","</span>);</span><br><span class="line">        traceTree(root.left, sb);</span><br><span class="line">        traceTree(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] dataArray = data.split(<span class="string">","</span>);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(dataArray));</span><br><span class="line">        <span class="keyword">return</span> deTraceTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deTraceTree</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"null"</span>.equals(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">        curr.left = deTraceTree(queue);</span><br><span class="line">        curr.right = deTraceTree(queue);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterative dfs pre-order tree traversal</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null,"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(curr.val);</span><br><span class="line">                sb.append(<span class="string">","</span>);</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"null,"</span>);</span><br><span class="line">                curr = stack.pop();</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] dataArray = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (dataArray.length == <span class="number">1</span> &amp;&amp; <span class="string">"null"</span>.equals(dataArray[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(dataArray[<span class="number">0</span>]));</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">int</span> len = dataArray.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; len &amp;&amp; !<span class="string">"null"</span>.equals(dataArray[index])) &#123;</span><br><span class="line">                String val = dataArray[index];</span><br><span class="line">                curr.left  = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; len &amp;&amp; <span class="string">"null"</span>.equals(dataArray[index])) &#123;</span><br><span class="line">                curr = stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; len) &#123;</span><br><span class="line">                String val = dataArray[index];</span><br><span class="line">                curr.right = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="331-M-Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#331-M-Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="331. [M]Verify Preorder Serialization of a Binary Tree"></a>331. [M]Verify Preorder Serialization of a Binary Tree</h3><ol>
<li>we could use recursive to traverse a tree. In the same way we could get the value in traversing process. poll() method would return null when queue is empty. It could not be null in this process and when the traversing process finished, the queue should be empty.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        String[] data = preorder.split(<span class="string">","</span>);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data));</span><br><span class="line">        <span class="keyword">return</span> dfs(queue) &amp;&amp; queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"#"</span>.equals(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dfs(queue) &amp;&amp; dfs(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>we could think about this problem in a different way. As we take null node as the leaf, all null-node has 0 out-degree and 1 in-degree. All non-null nodes has  2 out-degree and 1 in-degree except root. So the whole out-degree - in-degree = 1. So we could first let the diff = 1 and keep track of the difference between out-degree - in-degree. The difference could never be negative in the process and when the process done, the difference should be 0.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        String[] data = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String val: data) &#123;</span><br><span class="line">            diff -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"#"</span>.equals(val)) &#123;</span><br><span class="line">                diff += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="450-M-Delete-Node-in-a-BST"><a href="#450-M-Delete-Node-in-a-BST" class="headerlink" title="450. [M]Delete Node in a BST"></a>450. [M]Delete Node in a BST</h3><ol>
<li><p>Thinking about the root could be deleted, so I create a dummy node to represent the root and dummy nodeâ€™s left node will be the real node. So I could find and delete the node in the tree in the same way no matter itâ€™s root or not. Find the need-to-be-deleted nodeâ€™s father, find need-to-be-deleted nodeâ€™s right nodeâ€™s leftmost node. Connect the leftmost node with the left node.  </p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode dummyNode = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.left = root;</span><br><span class="line">        TreeNode delParNode = findNodeParent(dummyNode, key);</span><br><span class="line">        <span class="keyword">if</span> (delParNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delParNode.left != <span class="keyword">null</span> &amp;&amp; delParNode.left.val == key) &#123;</span><br><span class="line">            TreeNode delNode = delParNode.left;</span><br><span class="line">            <span class="keyword">if</span> (delNode.left != <span class="keyword">null</span> &amp;&amp; delNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode leftmostNode = findleftmostNode(delNode.right);</span><br><span class="line">                leftmostNode.left = delNode.left;</span><br><span class="line">                delParNode.left = delNode.right;</span><br><span class="line">                delNode.left = <span class="keyword">null</span>;</span><br><span class="line">                delNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                delParNode.left = delNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                delParNode.left = delNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delParNode.right != <span class="keyword">null</span> &amp;&amp; delParNode.right.val == key) &#123;</span><br><span class="line">            TreeNode delNode = delParNode.right;</span><br><span class="line">            <span class="keyword">if</span> (delNode.left != <span class="keyword">null</span> &amp;&amp; delNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode leftmostNode = findleftmostNode(delNode.right);</span><br><span class="line">                leftmostNode.left = delNode.left;</span><br><span class="line">                delParNode.right = delNode.right;</span><br><span class="line">                delNode.left = <span class="keyword">null</span>;</span><br><span class="line">                delNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                delParNode.right = delNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                delParNode.right = delNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findNodeParent</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == key) || (root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = findNodeParent(root.left, key);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? findNodeParent(root.right, key) : left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findleftmostNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using the feature of BST, we could recursively delete node. Itâ€™s much more efficient and concise. The time complexity is only O(h)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125; </span><br><span class="line">            TreeNode leftmost = findLeftmostNode(root.right);</span><br><span class="line">            leftmost.left = root.left;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findLeftmostNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a>889. Construct Binary Tree from Preorder and Postorder Traversal</h3><ol>
<li><p>we can split the preorder array and postorder array into three parts and do it by recursion.  Think about it. The preorder array could be split like this: [root][left part] [right part]. The postorder array could be split like this: [left part][right part][root]. Because the index of root is always so apparen, what we need to do is to find the index that split the right part and left part, Then split it. </p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = pre.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; post.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">1</span>] == post[index]) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = constructFromPrePost(Arrays.copyOfRange(pre, <span class="number">1</span>, left+<span class="number">1</span>), Arrays.copyOfRange(post, <span class="number">0</span>, left));</span><br><span class="line">        root.right = constructFromPrePost(Arrays.copyOfRange(pre, left+<span class="number">1</span>, len), Arrays.copyOfRange(post, left, len-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The time complexity would be O(N^2), space complexity would be O(N^2).</p>
</li>
<li><p>we could use index to mark the preorder sub-array and postorder sub-array so that we could save the space. </p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pre, post;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pre = pre;</span><br><span class="line">        <span class="keyword">this</span>.post = post;</span><br><span class="line">        <span class="keyword">return</span> construct(<span class="number">0</span>, <span class="number">0</span>, pre.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span> preHead, <span class="keyword">int</span> postHead, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preHead]);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preHead+<span class="number">1</span>] == post[postHead+index]) &#123;</span><br><span class="line">                newLen = index + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = construct(preHead+<span class="number">1</span>, postHead, newLen);</span><br><span class="line">        root.right = construct(preHead+newLen+<span class="number">1</span>, postHead+newLen, len-newLen-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this way only O(n) space complexity. </p>
</li>
</ol>
<h3 id="863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="863. All Nodes Distance K in Binary Tree"></a>863. All Nodes Distance K in Binary Tree</h3><ol>
<li><p>First using dfs to find the path from root to the target node. Then for each node in the path, find the nodes in relevant distance by using bfs. There are many corner case need to watch out. When find the relevant distance nodes, we should cut the branch off which has already been searched for.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || target == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">boolean</span> isFind = dfs(stack, target);</span><br><span class="line">        <span class="keyword">if</span> (!isFind) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = <span class="keyword">null</span>, last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> distance = K; distance &gt;=<span class="number">0</span>; distance--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            getNodeDistanceK(curr, last, distance, result);</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(Stack&lt;TreeNode&gt; stack, TreeNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curr = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (curr == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr.left);</span><br><span class="line">            isFind |= dfs(stack, target);</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">return</span> isFind;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr.right);</span><br><span class="line">            isFind |= dfs(stack, target);</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">return</span> isFind;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNodeDistanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (level == K) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; it &lt; size; it++) &#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span> &amp;&amp; temp.left != target) &#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span> &amp;&amp; temp.right != target) &#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node: queue) &#123;</span><br><span class="line">            result.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h3><ol>
<li><p>we could use partition which is used in quick sort to solve it. what we are doing is to find the k-th number, each time we use the first num as a pivot and find the index of this number as j, if it match k-th, stop sorting and return it. If it small than k, move low side to j + 1. Else move high side to j-1.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> kth = nums.length - k;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span> (j == kth) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; kth) &#123;</span><br><span class="line">                low = j + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[kth];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> li = low;</span><br><span class="line">        <span class="keyword">int</span> hi = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(li &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; li &amp;&amp; nums[low] &lt; nums[--hi]);</span><br><span class="line">            <span class="keyword">while</span>(li &lt; hi &amp;&amp; nums[low] &gt; nums[++li]);</span><br><span class="line">            <span class="keyword">if</span> (hi == li) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(nums, li, hi);</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums, low, li);</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this method would run in O(N) best case / O(N^2) worst case running time + O(1) memory.</p>
</li>
<li><p>we need to improve the method to get O(n) guaranteed time complexity. Just Randomize the input so that it wonâ€™t infect even if the worst case happen. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ind = <span class="number">1</span>; ind &lt; a.length; ind++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = random.nextInt(ind + <span class="number">1</span>);</span><br><span class="line">        exchange(a, ind, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324. Wiggle Sort II"></a>324. Wiggle Sort II</h3><ol>
<li><p>In this problem, I need to use the function in 215 findKthLargest() to get the median number first in O(n) time and O(1) space. Then Because the nuns would be seperate two part by findKthLargest(), the first part is small than median, the last part is large than median.  For the regulation, we use S represent small, M represent equal, L represent large. So the array would be something like this: S, S, S, M, M, L, L, L. What we want is to change this arrage into this style: M, L, S, L, S, L, S, L, M. We could use the equation to map index. Real(i) = (i * 2 + 1) % (Len | 1). This equation could make the first part map to first odd place, and map the last part map to last even. So the median would be map into last odd part and first even part to be separated.  <strong>(n | 1) calculates the nearest odd that is not less than n.</strong></p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> midValue = findKthLargest(nums, (nums.length+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        System.out.println(midValue);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, bt = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (bt &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> realBt = getRealIndex(bt, len);</span><br><span class="line">            <span class="keyword">int</span> realLow = getRealIndex(low, len);</span><br><span class="line">            <span class="keyword">int</span> realHigh = getRealIndex(high, len);</span><br><span class="line">            <span class="keyword">if</span> (nums[realBt] &gt; midValue)&#123;</span><br><span class="line">                exchange(nums, realBt, realLow);</span><br><span class="line">                bt++;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[realBt] &lt; midValue) &#123;</span><br><span class="line">                exchange(nums, realBt, realHigh);</span><br><span class="line">                high--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRealIndex</span><span class="params">(<span class="keyword">int</span> vi, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + vi * <span class="number">2</span>) % (len | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Or we could not use the virtual index, just follow the rules to swap the array. We need to put the value which is smaller than median into the last even slot, put the value which is larger than median into the first odd slot. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> midValue = findKthLargest(nums, (nums.length+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">       System.out.println(midValue);</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">1</span>, right = (nums.length - <span class="number">1</span>) / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = right;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; midValue)&#123;</span><br><span class="line">               exchange(nums, mid, left);</span><br><span class="line">               left += <span class="number">2</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; midValue) &#123;</span><br><span class="line">               exchange(nums, mid, right);</span><br><span class="line">               right -= <span class="number">2</span>;</span><br><span class="line">               mid -= <span class="number">2</span>;</span><br><span class="line">               <span class="keyword">if</span> (mid &lt; <span class="number">0</span>) mid = nums.length  / <span class="number">2</span> * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mid -= <span class="number">2</span>;</span><br><span class="line">               <span class="keyword">if</span> (mid &lt; <span class="number">0</span>) mid = nums.length / <span class="number">2</span> * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h3><ol>
<li><p>we could use fast-slow pointer to find the root of each node, then recursively solve it.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> toBST(head, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> TreeNode <span class="title">toBST</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       ListNode fast = head;</span><br><span class="line">       <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode thead = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">       thead.left = toBST(head, slow);</span><br><span class="line">       thead.right = toBST(slow.next, tail);</span><br><span class="line">       <span class="keyword">return</span> thead;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 417. Pacific Atlantic Water Flow</span><br><span class="line"></span><br><span class="line">1. we could use dfs to find the answer. As there are two destination we need to reach, we could use two boolean array to mark each way, every time reach one place, change it to visited. To initial it, there are the edges which are already satisfy the request and each new node which could get to these node are still satisfy the request.</span><br><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   class Solution &#123;</span><br><span class="line">       public List&lt;int[]&gt; pacificAtlantic(int[][] matrix) &#123;</span><br><span class="line">           List&lt;int[]&gt; answer = new ArrayList&lt;&gt;();</span><br><span class="line">           if(matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">               return answer;</span><br><span class="line">           &#125;</span><br><span class="line">           int m = matrix.length;</span><br><span class="line">           int n = matrix[0].length;</span><br><span class="line">           boolean[][] pacific = new boolean[m][n];</span><br><span class="line">           boolean[][] atlantic = new boolean[m][n];</span><br><span class="line">           for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">               dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);</span><br><span class="line">               dfs(matrix, atlantic, Integer.MIN_VALUE, i, n-1);</span><br><span class="line">           &#125; </span><br><span class="line">           for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">               dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);</span><br><span class="line">               dfs(matrix, atlantic, Integer.MIN_VALUE, m-1, i);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for (int row = 0; row &lt; m; row++) &#123;</span><br><span class="line">               for (int column = 0; column &lt; n; column++) &#123;</span><br><span class="line">                   if (pacific[row][column] &amp;&amp; atlantic[row][column]) &#123;</span><br><span class="line">                       int[] one = &#123;row, column&#125;;</span><br><span class="line">                       answer.add(one);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return answer;</span><br><span class="line">       &#125;</span><br><span class="line">       private void dfs(int[][] matrix, boolean[][] visited, int height, int row, int column) &#123;</span><br><span class="line">           if (row &lt; 0 || row &gt;= matrix.length || column &lt; 0 || column &gt;= matrix[0].length || visited[row][column] || matrix[row][column] &lt; height) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           visited[row][column] = true;</span><br><span class="line">           int[][] direction = &#123;&#123;1,0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">           for (int index = 0; index &lt; direction.length; index++) &#123;</span><br><span class="line">               dfs(matrix, visited, matrix[row][column], row+direction[index][0], column+direction[index][1]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>we also could use bfs to achieve this goal. Just use queue to replace the recursion.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> answer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] pacific = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; pQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; aQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pStart = &#123;i, <span class="number">0</span>&#125;;</span><br><span class="line">            pQueue.offer(pStart);</span><br><span class="line">            <span class="keyword">int</span>[] aStart = &#123;i, n-<span class="number">1</span>&#125;;</span><br><span class="line">            aQueue.offer(aStart);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pStart = &#123;<span class="number">0</span>, i&#125;;</span><br><span class="line">            pQueue.offer(pStart);</span><br><span class="line">            <span class="keyword">int</span>[] aStart = &#123;m-<span class="number">1</span>, i&#125;;</span><br><span class="line">            aQueue.offer(aStart);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(matrix, pacific, pQueue);</span><br><span class="line">        bfs(matrix, atlantic, aQueue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; column++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pacific[row][column] &amp;&amp; atlantic[row][column]) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] one = &#123;row, column&#125;;</span><br><span class="line">                    answer.add(one);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, Queue&lt;<span class="keyword">int</span>[]&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> row = curr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> column = curr[<span class="number">1</span>];</span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: direction) &#123;</span><br><span class="line">                <span class="keyword">int</span> tRow = row + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tColumn = column + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (tRow &lt; <span class="number">0</span> || tRow &gt;= matrix.length || tColumn &lt; <span class="number">0</span> || tColumn &gt;= matrix[<span class="number">0</span>].length || visited[tRow][tColumn] || matrix[row][column] &gt; matrix[tRow][tColumn]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span>[] temp = &#123;tRow, tColumn&#125;;</span><br><span class="line">                queue.offer(temp);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h3><ol>
<li><p>I use two stack to record the valid Parentheses. The first stack is to valid, the second one just record the index of each Parentheses and do the same push, pop as the first one. So when the second stack has elements left, which is exactly the invalid Parentheses. Finally i could pop this stack then calculate the length between each invalid Parentheses which shoud be the length of valid Parentheses. Time complexity O(n), space complexity O(n).</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; indexStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; chars[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.empty() &amp;&amp; stack.peek() == <span class="string">'('</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    indexStack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(chars[i]);</span><br><span class="line">                    indexStack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= chars.length)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(chars[i]);   </span><br><span class="line">            indexStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = chars.length;</span><br><span class="line">        <span class="keyword">while</span> (!indexStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = indexStack.pop();</span><br><span class="line">            max = Math.max(max, last-curr-<span class="number">1</span>);</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max &gt; last ? max : last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using the same method as before, just try to save the space complexity, we could only use one stack to record. First put -1 into the stack so that if all index has been pop out, the length will be the last index -1, still right. Time complexity O(n), space complexity O(n)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i-stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>We could use dynamic programming method to solve this problem. Define the dp[i] represent the longest valid parentheses which end up with the index i. To avoid some corner case, we just define the dp array as dp[s.length+1] so that dp[i] represent which end up as index i-1. And the state transition equation would have two situation: if like this: (), the equation would be <strong>dp[i+1] = dp[i-1] + 2</strong>, if like (()), the equation would be like:    dp[i+1] = dp[i] + dp[i-dp[i]-1] + 2.  Time complexity O(n), space complexity O(n)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[chars.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i-<span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    max = Math.max(dp[i+<span class="number">1</span>], max);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] &lt; i &amp;&amp; chars[i-dp[i]-<span class="number">1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i] + dp[i-dp[i]-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    max = Math.max(dp[i+<span class="number">1</span>], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="bitCount-count-the-oneâ€™s-number-in-a-integer-in-O-1"><a href="#bitCount-count-the-oneâ€™s-number-in-a-integer-in-O-1" class="headerlink" title="bitCount: count the oneâ€™s number in a integer in O(1)"></a>bitCount: count the oneâ€™s number in a integer in O(1)</h3><ol>
<li>This is the jdk source code to implement it. The idea is based on a regular patternã€‚ </li>
</ol>
<table>
<thead>
<tr>
<th>Binary code for number</th>
<th>number</th>
<th>bit number</th>
<th>binary bit number</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>00 - 00</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td>1</td>
<td>01 - 00</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>1</td>
<td>10 - 01</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>2</td>
<td>11 - 01</td>
</tr>
</tbody>
</table>
<p>   So for every two binary number n, its oneâ€™s bit number is equal to <strong>n - (n &gt;&gt;1)</strong> </p>
<p>   Then we just combine the every two number into every four number, then increase to 8, 16, Then clear the high address oneâ€™s bit and got the answer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/23/composition-mod/">Exponentiating by Squaring(å¿«é€Ÿå¹‚)</a><a class="next" href="/2018/05/15/coding note 8--data structure/">coding note 8 Data Structure</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://zhangyuzhu13.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/System-Design/">System Design</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/factory/" style="font-size: 15px;">factory</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/multithreading/" style="font-size: 15px;">multithreading</a> <a href="/tags/observer-pattern/" style="font-size: 15px;">observer pattern</a> <a href="/tags/prototype/" style="font-size: 15px;">prototype</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/singleton/" style="font-size: 15px;">singleton</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/01/14/Prepare for Google Onsite/">Prepare for Google Onsite</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/Unique Path Problem/">Unique Path Problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/27/Proxy Pattern/">Proxy Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/Observer Pattern/">Observer Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/Modern Family/">Modern Family</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/Tiny Point/">Tiny Point</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Factory Pattern/">Factory Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/Multithreading/">Multithreading in Java â€”â€”Synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/Prototype Pattern/">Prototype Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/Singleton Pattern/">Singleton Pattern</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright Â© 2019 <a href="/." rel="nofollow">Drew's Tahiti.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>